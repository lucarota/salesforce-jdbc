package com.ascendix.jdbc.salesforce.statement;

import com.ascendix.jdbc.salesforce.cache.CacheConfig;
import com.ascendix.jdbc.salesforce.connection.ForceConnection;
import com.ascendix.jdbc.salesforce.delegates.ForceResultField;
import com.ascendix.jdbc.salesforce.delegates.PartnerService;
import com.ascendix.jdbc.salesforce.metadata.ColumnMap;
import com.ascendix.jdbc.salesforce.metadata.ForceDatabaseMetaData;
import com.ascendix.jdbc.salesforce.metadata.TypeInfo;
import com.ascendix.jdbc.salesforce.resultset.CachedResultSet;
import com.ascendix.jdbc.salesforce.statement.processor.AdminQueryProcessor;
import com.ascendix.jdbc.salesforce.statement.processor.DeleteQueryAnalyzer;
import com.ascendix.jdbc.salesforce.statement.processor.DeleteQueryProcessor;
import com.ascendix.jdbc.salesforce.statement.processor.InsertQueryAnalyzer;
import com.ascendix.jdbc.salesforce.statement.processor.InsertQueryProcessor;
import com.ascendix.jdbc.salesforce.statement.processor.QueryAnalyzer;
import com.ascendix.jdbc.salesforce.statement.processor.SoqlQueryAnalyzer;
import com.ascendix.jdbc.salesforce.statement.processor.StatementTypeEnum;
import com.ascendix.jdbc.salesforce.statement.processor.UpdateQueryAnalyzer;
import com.ascendix.jdbc.salesforce.statement.processor.UpdateQueryProcessor;
import com.sforce.ws.ConnectionException;
import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.sql.rowset.RowSetMetaDataImpl;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.ehcache.Cache;

@Slf4j
public class ForcePreparedStatement implements PreparedStatement, Iterator<List<ColumnMap<String, Object>>> {

    private static final Pattern CACHE_HINT = Pattern.compile("(?is)\\A\\s*(CACHE\\s*(GLOBAL|SESSION)).*");

    protected enum CacheMode {
        NO_CACHE, GLOBAL, SESSION
    }

    private String soqlQuery;
    private final ForceConnection connection;
    private PartnerService partnerService;
    private ResultSetMetaData metadata;
    private int fetchSize;
    private int maxRows;
    private final List<Object> parameters = new ArrayList<>();
    private CacheMode cacheMode;
    @Setter
    private int updateCount = -1;
    private boolean updateCountReturned = false;
    @Setter
    private ResultSet resultSet;
    private boolean resultSetReturned = false;
    private SQLWarning warnings = new SQLWarning();
    private boolean neverQueriedMore;
    private String queryMoreLocator;
    private int autoGeneratedKeys;
    private int fetchDirection;

    private static final CacheConfig cacheDb = CacheConfig.getInstance();
    private static final Cache<String, CachedResultSet> dataCache = cacheDb.getDataCache();
    private static final Cache<String, ResultSetMetaData> metadataCache = cacheDb.getMetaDataCache();

    public ForcePreparedStatement(ForceConnection connection) {
        if (connection == null) {
            throw new IllegalArgumentException("Invalid value. Connection cannot be null.");
        }
        this.connection = connection;
        this.fetchDirection = ResultSet.FETCH_FORWARD;
        this.autoGeneratedKeys = Statement.NO_GENERATED_KEYS;
        this.partnerService = connection.getPartnerService();
    }

    public ForcePreparedStatement(ForceConnection connection, String soql) {
        this(connection);
        this.soqlQuery = soql;
    }

    public ForcePreparedStatement(ForceConnection connection, String soql, int autoGeneratedKeys) {
        this(connection, soql);
        this.autoGeneratedKeys = autoGeneratedKeys;
    }

    public static <T extends Throwable> void rethrowAsNonChecked(Throwable throwable) throws T {
        throw (T) throwable; // rely on vacuous cast
    }

    @Override
    public ResultSet executeQuery() throws SQLException {
        executeInternal(soqlQuery, Statement.NO_GENERATED_KEYS);
        return this.resultSet;
    }

    private void executeInternal(String soql, int autoGeneratedKeys) throws SQLException {
        this.autoGeneratedKeys = autoGeneratedKeys;
        this.updateCount = -1;
        this.updateCountReturned = false;
        this.resultSetReturned = false;
        setCacheMode(soql);
        this.resultSet = cacheMode == CacheMode.NO_CACHE
            ? query()
            : loadFromDataCache();
    }

    private CachedResultSet query() throws SQLException {
        log.trace("[PrepStat] query IMPLEMENTED {}", soqlQuery);
        if ("SELECT 'keep alive'".equals(soqlQuery)) {
            log.info("[PrepStat] query KEEP ALIVE ");
            return CachedResultSet.EMPTY;
        }

        if (AdminQueryProcessor.isAdminQuery(soqlQuery)) {
            return AdminQueryProcessor.processQuery(this, soqlQuery);
        }

        final QueryAnalyzer analyzer = getQueryAnalyzer();

        if (analyzer.analyse(soqlQuery, StatementTypeEnum.INSERT)) {
            return InsertQueryProcessor.processQuery(this, soqlQuery, partnerService, getInsertQueryAnalyzer());
        }
        if (analyzer.analyse(soqlQuery, StatementTypeEnum.UPDATE)) {
            return UpdateQueryProcessor.processQuery(this, soqlQuery, partnerService, getUpdateQueryAnalyzer());
        }
        if (analyzer.analyse(soqlQuery, StatementTypeEnum.DELETE)) {
            return DeleteQueryProcessor.processQuery(soqlQuery, partnerService, getDeleteQueryAnalyzer());
        }

        try {
            final ResultSetMetaData metaData = getMetaData();
            if (cacheMode == CacheMode.NO_CACHE) {
                this.neverQueriedMore = true;
                return new CachedResultSet(this, metaData);
            }
            List<FieldDef> fieldDefs = getRootEntityFieldDefinitions();
            List<List> forceQueryResult = partnerService.query(prepareQuery(getSoqlQueryAnalyzer().getSoqlQuery()), fieldDefs);
            if (!forceQueryResult.isEmpty()) {
                List<ColumnMap<String, Object>> maps = Collections.synchronizedList(new LinkedList<>());
                forceQueryResult.forEach(rec -> maps.add(convertToColumnMap(rec)));
                return new CachedResultSet(maps, metaData);
            } else {
                return new CachedResultSet(Collections.emptyList(), metaData);
            }
        } catch (ConnectionException e) {
            throw new SQLException(e);
        }
    }

    public boolean hasAutoGeneratedKeys() {
        return this.autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS;
    }

    @Override
    public boolean hasNext() {
        return this.neverQueriedMore || this.queryMoreLocator != null;
    }

    @Override
    @SuppressWarnings({"rawtypes", "unchecked"})
    public List<ColumnMap<String, Object>> next() {
        try {
            Map.Entry<List<List>, String> resultEntry;
            if (this.neverQueriedMore) {
                this.neverQueriedMore = false;
                resultEntry = partnerService.queryStart(prepareQuery(getSoqlQueryAnalyzer().getSoqlQuery()),
                    getRootEntityFieldDefinitions());
            } else if (this.queryMoreLocator != null) {
                resultEntry = partnerService.queryMore(this.queryMoreLocator, getRootEntityFieldDefinitions());
            } else {
                return Collections.emptyList();
            }
            this.queryMoreLocator = resultEntry.getValue();
            List result = Collections.synchronizedList(new LinkedList<>());
            Optional.ofNullable(resultEntry.getKey())
                .orElseGet(Collections::emptyList)
                .forEach(rec -> result.add(convertToColumnMap(rec)));
            return result;
        } catch (ConnectionException e) {
            throw new RuntimeException(new SQLException(e));
        }
    }

    private String prepareQuery(String query) {
        log.trace("[PrepStat] prepareQuery IMPLEMENTED {}", query);
        query = preprocessQuery(query);
        return setParams(query);
    }

    private String preprocessQuery(String soqlQuery) {
        // Preprocess some sugar like Date Literals into SOQL format
        // {ts '2021-10-12 00:00:12Z'}
        // 2021-10-12T00:00:12Z
        if (soqlQuery == null) {
            return soqlQuery;
        }
        String soqlQueryProcessed = soqlQuery;
        if (soqlQuery.contains("{ts")) {
            soqlQueryProcessed = soqlQuery.trim()
                .replaceAll(
                    "\\{ts\\s*'(\\d\\d\\d\\d-\\d\\d-\\d\\d)(T|\\s)(\\d\\d:\\d\\d:\\d\\d)(Z|[+-]\\d\\d\\d\\d|)'\\}",
                    "$1T$3$4");
        }
        return soqlQueryProcessed;
    }

    private ColumnMap<String, Object> convertToColumnMap(List<ForceResultField> recordFields) {
        ColumnMap<String, Object> columnMap = new ColumnMap<>();
        // Flatten not only child records, but also Lists of Lists - for Relations - list of subrecords
        recordFields = flatten(recordFields);
        recordFields.stream()
            .map(field -> field == null ? new ForceResultField() : field)
            .forEach(field -> {
                TypeInfo typeInfo = TypeInfo.OTHER_TYPE_INFO;
                if (field.getFieldType() != null) {
                    typeInfo = TypeInfo.lookupTypeInfo(field.getFieldType());
                }
                if (typeInfo == TypeInfo.OTHER_TYPE_INFO) {
                    typeInfo = findColumnType(field.getName());
                }
                columnMap.put(field.getFullName(), field.getValue(), typeInfo);
            });
        return columnMap;
    }

    private TypeInfo findColumnType(String name) {
        if (name == null) {
            return TypeInfo.OTHER_TYPE_INFO;
        }
        try {
            for (int i = 1; i <= metadata.getColumnCount(); i++) {
                if (name.equalsIgnoreCase(metadata.getColumnName(i))) {
                    return TypeInfo.lookupTypeInfo(metadata.getColumnTypeName(i));
                }
            }
        } catch (SQLException e) {
            // ignore
        }
        return TypeInfo.OTHER_TYPE_INFO;
    }

    protected void setCacheMode(String query) {
        Matcher matcher = CACHE_HINT.matcher(query);
        if (matcher.matches()) {
            String mode = matcher.group(2);
            String hint = matcher.group(1);
            this.soqlQuery = query.replaceFirst(hint, "");
            this.cacheMode = CacheMode.valueOf(mode.toUpperCase());
        } else {
            this.soqlQuery = query;
            this.cacheMode = CacheMode.NO_CACHE;
        }
    }

    private String getCacheKey() {
        String preparedQuery = prepareQuery(soqlQuery);
        String key = cacheMode == CacheMode.GLOBAL
            ? preparedQuery
            : connection.getUUID() + preparedQuery;
        return sha256(key);
    }

    private String sha256(final String key) {
        try {
            final MessageDigest digest = MessageDigest.getInstance("SHA-256");
            final byte[] hash = digest.digest(key.getBytes(StandardCharsets.UTF_8));
            final StringBuilder hexString = new StringBuilder();
            for (final byte b : hash) {
                final String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (Exception ex) {
            return key;
        }
    }

    public List<Object> getParameters() {
        log.trace("[PrepStat] getParameters IMPLEMENTED {}", soqlQuery);
        int paramsCountInQuery = StringUtils.countMatches(soqlQuery, '?');
        log.info("[PrepStat] getParameters   detected {} parameters", paramsCountInQuery);
        log.info("[PrepStat] getParameters   parameters provided {}", parameters.size());
        if (parameters.size() < paramsCountInQuery) {
            parameters.addAll(Collections.nCopies(paramsCountInQuery - parameters.size(), null));
        }
        return parameters;
    }

    protected String setParams(String soql) {
        log.trace("[PrepStat] setParams IMPLEMENTED {}", soql);
        String result = soql;
        for (Object param : getParameters()) {
            String paramRepresentation = convertToSoqlParam(param);
            result = result.replaceFirst("\\?", paramRepresentation);
        }
        return result;
    }

    private static final Map<Class<?>, Function<Object, String>> paramConverters = new HashMap<>();

    public static final String ISO_DATETIME = "yyyy-MM-dd'T'HH:mm:ssZ";

    static {
        paramConverters.put(String.class, ForcePreparedStatement::toSoqlStringParam);
        paramConverters.put(Object.class, ForcePreparedStatement::toSoqlStringParam);
        paramConverters.put(Boolean.class, Object::toString);
        paramConverters.put(Double.class, Object::toString);
        paramConverters.put(BigDecimal.class, Object::toString);
        paramConverters.put(Float.class, Object::toString);
        paramConverters.put(Integer.class, Object::toString);
        paramConverters.put(Long.class, Object::toString);
        paramConverters.put(Short.class, Object::toString);
        paramConverters.put(java.util.Date.class, new SimpleDateFormat(ISO_DATETIME)::format);
        paramConverters.put(Timestamp.class, new SimpleDateFormat(ISO_DATETIME)::format);
        paramConverters.put(null, p -> "NULL");
    }

    protected static String toSoqlStringParam(Object param) {
        return "'" + param.toString().replaceAll("\\\\", "\\\\\\\\").replaceAll("'", "\\\\'") + "'";
    }

    protected static String convertToSoqlParam(Object paramValue) {
        Class<?> paramClass = getParamClass(paramValue);
        // Convert the string date representation to SOQL
        // like {ts '2021-10-21 12:01:02Z'}
        // to 2021-10-21 12:01:02-0000
        if (String.class.equals(paramClass) && ((String) paramValue).startsWith("{ts")) {
            paramValue = convertStringToDate((String) paramValue);
            paramClass = getParamClass(paramValue);
        }
        return paramConverters.get(paramClass).apply(paramValue);
    }

    private static java.util.Date convertStringToDate(String paramValue) {
        if (paramValue == null) {
            return null;
        }
        try {
            String paramValueCleared = paramValue.trim()
                .replaceAll("^\\{ts\\s*'(.*)'\\}$", "$1")
                .replaceAll("Z$", "+0000");
            return new SimpleDateFormat(ISO_DATETIME).parse(paramValueCleared);
        } catch (ParseException e) {
            log.error("Failed to convert value to date [{}]", paramValue, e);
        }
        return null;
    }

    protected static Class<?> getParamClass(Object paramValue) {
        Class<?> paramClass = paramValue != null ? paramValue.getClass() : null;
        if (!paramConverters.containsKey(paramClass)) {
            paramClass = Object.class;
        }
        return paramClass;
    }

    public static ResultSetMetaData createMetaData(ColumnMap<String, Object> row) {
        if (row == null) {
            return null;
        }
        try {
            log.trace("[PrepStat] dummyMetaData IMPLEMENTED");
            RowSetMetaDataImpl result = new RowSetMetaDataImpl();
            int columnsCount = row.size();
            result.setColumnCount(columnsCount);
            for (int i = 1; i <= columnsCount; i++) {
                String fieldName = row.getColumnNames().get(i - 1);
                result.setAutoIncrement(i, false);
                result.setColumnName(i, fieldName);
                result.setColumnLabel(i, fieldName);
                TypeInfo typeInfo = row.getTypes().get(i - 1);
                log.trace(
                    "[PrepStat] createMetaData (" + i + ") " + fieldName + " : " + typeInfo.getTypeName() + " => "
                        + typeInfo.getSqlDataType());
                result.setColumnType(i, typeInfo.getSqlDataType());
                result.setColumnTypeName(i, typeInfo.getTypeName());
                result.setPrecision(i, typeInfo.getPrecision());
                result.setSchemaName(i, ForceDatabaseMetaData.DEFAULT_SCHEMA);
                result.setCatalogName(i, ForceDatabaseMetaData.DEFAULT_CATALOG);
                result.setTableName(i, null);
                result.setCaseSensitive(i, false);
            }
            return result;
        } catch (Exception e) {
            // Ignore for metadata - just return empty
            log.warn("Failed to compile dummy metadata information", e);
            return null;
        }
    }

    private ResultSetMetaData loadMetaData() throws SQLException {
        try {
            log.trace("[PrepStat] loadMetaData IMPLEMENTED");
            if (metadata == null) {
                RowSetMetaDataImpl result = new RowSetMetaDataImpl();
                SoqlQueryAnalyzer analyzer = getSoqlQueryAnalyzer();
                List<FieldDef> resultFieldDefinitions = getRootEntityFieldDefinitions();
                int columnsCount = resultFieldDefinitions.size();
                result.setColumnCount(columnsCount);
                for (int i = 1; i <= columnsCount; i++) {
                    FieldDef field = resultFieldDefinitions.get(i - 1);
                    result.setAutoIncrement(i, false);
                    result.setColumnName(i, field.getName());
                    result.setColumnLabel(i, field.getAlias());
                    String forceTypeName = field.getType();
                    TypeInfo typeInfo = TypeInfo.lookupTypeInfo(forceTypeName);
                    result.setColumnType(i, typeInfo.getSqlDataType());
                    result.setColumnTypeName(i, typeInfo.getTypeName());
                    result.setPrecision(i, typeInfo.getPrecision());
                    result.setSchemaName(i, ForceDatabaseMetaData.DEFAULT_SCHEMA);
                    result.setCatalogName(i, ForceDatabaseMetaData.DEFAULT_CATALOG);
                    result.setTableName(i, analyzer.getFromObjectName());
                    result.setCaseSensitive(i, false);
                }
                metadata = result;
            }
            return metadata;
        } catch (RuntimeException e) {
            throw new SQLException(e.getCause() != null ? e.getCause() : e);
        }
    }

    private <T> List<T> flatten(List<T> listWithLists) {
        log.trace("[PrepStat] flatten IMPLEMENTED ");
        return listWithLists.stream()
            .flatMap(
                def -> def instanceof Collection
                    ? flatten((List<T>) def).stream() // MultiLevel flattening
                    : Stream.of(def)
            ).toList();
    }

    private List<FieldDef> fieldDefinitions;

    private List<FieldDef> getRootEntityFieldDefinitions() {
        log.trace("[PrepStat] getFieldDefinitions IMPLEMENTED ");
        if (fieldDefinitions == null) {
            fieldDefinitions = getSoqlQueryAnalyzer().getFieldDefinitions();
            log.info("[PrepStat] getFieldDefinitions:\n  {}",
                fieldDefinitions.stream()
                    .map(fd -> fd.getName() + ":" + fd.getType())
                    .collect(Collectors.joining("\n  ")));
        }
        return fieldDefinitions;
    }

    private QueryAnalyzer queryAnalyzer;
    private SoqlQueryAnalyzer soqlQueryAnalyzer;
    private InsertQueryAnalyzer insertQueryAnalyzer;
    private UpdateQueryAnalyzer updateQueryAnalyzer;
    private DeleteQueryAnalyzer deleteQueryAnalyzer;

    private QueryAnalyzer getQueryAnalyzer() {
        if (queryAnalyzer == null) {
            queryAnalyzer = new QueryAnalyzer(soqlQuery, this::runResolveSubselect, partnerService);
        }
        return queryAnalyzer;
    }

    private SoqlQueryAnalyzer getSoqlQueryAnalyzer() {
        if (soqlQueryAnalyzer == null) {
            soqlQueryAnalyzer = new SoqlQueryAnalyzer(getQueryAnalyzer());
            if (soqlQueryAnalyzer.isExpandedStarSyntaxForFields()) {
                this.soqlQuery = soqlQueryAnalyzer.getSoqlQuery();
                log.info("[PrepStat] Expanded Star Syntax to {}", soqlQuery);
            }
        }
        return soqlQueryAnalyzer;
    }

    private InsertQueryAnalyzer getInsertQueryAnalyzer() {
        if (insertQueryAnalyzer == null) {
            insertQueryAnalyzer = new InsertQueryAnalyzer(getQueryAnalyzer());
        }
        return insertQueryAnalyzer;
    }

    private UpdateQueryAnalyzer getUpdateQueryAnalyzer() {
        if (updateQueryAnalyzer == null) {
            updateQueryAnalyzer = new UpdateQueryAnalyzer(getQueryAnalyzer());
        }
        return updateQueryAnalyzer;
    }

    private DeleteQueryAnalyzer getDeleteQueryAnalyzer() {
        if (deleteQueryAnalyzer == null) {
            deleteQueryAnalyzer = new DeleteQueryAnalyzer(getQueryAnalyzer());
        }
        return deleteQueryAnalyzer;
    }

    private List<Map<String, Object>> runResolveSubselect(String soql) {
        List<Map<String, Object>> results = new ArrayList<>();
        log.info("Resolving subselect \n{}", soql);
        try {
            ForcePreparedStatement forcePreparedStatement = new ForcePreparedStatement(connection, soql);
            ResultSet rs = forcePreparedStatement.query();

            while (rs.next()) {
                // LinkedHashMap is needed to save the order of the fields
                Map<String, Object> rec = new LinkedHashMap<>();
                results.add(rec);
                for (int i = 0; i < rs.getMetaData().getColumnCount(); i++) {
                    rec.put(rs.getMetaData().getColumnName(i + 1), rs.getString(i + 1));
                }
            }
            log.info("  {} records resolved with {} columns", results.size(), rs.getMetaData().getColumnCount());
        } catch (Exception e) {
            log.warn("Failed to resolve sub-select \n{}", soql, e);
            this.warnings.addSuppressed(new SQLWarning("Failed to resolve sub-select \n" + soql, e));
            throw new IllegalArgumentException("Failed to resolve sub-select: " + e.getMessage());
        }

        return results;
    }

    @Override
    public ParameterMetaData getParameterMetaData() {
        return new ParameterMetadataImpl(parameters, soqlQuery);
    }

    public ResultSetMetaData getMetaData() throws SQLException {
        log.trace("[PrepStat] getMetaData IMPLEMENTED ");
        return cacheMode == CacheMode.NO_CACHE
            ? loadMetaData()
            : loadFromMetaDataCache();
    }

    private ResultSetMetaData loadFromMetaDataCache() {
        String key = getCacheKey();
        if (metadataCache.containsKey(key)) {
            return metadataCache.get(key);
        }

        ResultSetMetaData value;
        try {
            value = loadMetaData();
        } catch (SQLException e) {
            rethrowAsNonChecked(e);
            return null;
        }

        metadataCache.put(key, value);
        this.metadata = value;
        return value;
    }

    private synchronized ResultSet loadFromDataCache() {
        CachedResultSet value;
        String key = getCacheKey();
        if (dataCache.containsKey(key)) {
            value = dataCache.get(key);
            value.beforeFirst();
            return value;
        }

        try {
            value = query();
        } catch (SQLException e) {
            rethrowAsNonChecked(e);
            return null;
        }

        dataCache.put(key, value);
        return value;
    }

    public boolean reconnect(String url, String userName, String userPass) throws ConnectionException {
        log.trace("[PrepStat] RECONNECT IMPLEMENTED newUserName={} url={}", userName, url);
        boolean updated = connection.updatePartnerConnection(url, userName, userPass);
        this.partnerService = connection.getPartnerService();
        return updated;
    }

    @Override
    public void setFetchSize(int rows) {
        this.fetchSize = rows;
    }

    @Override
    public int getFetchSize() {
        return fetchSize;
    }

    @Override
    public void setMaxRows(int max) {
        this.maxRows = max;
    }

    @Override
    public int getMaxRows() {
        return maxRows;
    }

    protected void addParameter(int parameterIndex, Object x) {
        log.trace("[PrepStat] addParameter {} IMPLEMENTED", parameterIndex);
        parameterIndex--;
        if (parameters.size() < parameterIndex) {
            parameters.addAll(Collections.nCopies(parameterIndex - parameters.size(), null));
        }
        parameters.add(parameterIndex, x);
    }

    @Override
    public void setBigDecimal(int parameterIndex, BigDecimal x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setBoolean(int parameterIndex, boolean x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setByte(int parameterIndex, byte x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setDate(int parameterIndex, Date x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setDouble(int parameterIndex, double x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setFloat(int parameterIndex, float x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setInt(int parameterIndex, int x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setLong(int parameterIndex, long x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setNull(int parameterIndex, int sqlType) {
        addParameter(parameterIndex, null);
    }

    @Override
    public void setNull(int paramIndex, int sqlType, String typeName) {
        addParameter(paramIndex, null);
    }

    @Override
    public void setObject(int parameterIndex, Object x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setObject(int parameterIndex, Object x, int targetSqlType) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setShort(int parameterIndex, short x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setString(int parameterIndex, String x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setTime(int parameterIndex, Time x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setTimestamp(int parameterIndex, Timestamp x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        log.trace("[PrepStat] executeQuery IMPLEMENTED {}", sql);
        this.resultSet = executeQuery();
        return this.resultSet;
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        return executeUpdate(sql, this.autoGeneratedKeys);
    }

    // Not required to implement below

    @Override
    public void close() {
        parameters.clear();
    }

    @Override
    public int getMaxFieldSize() {
        return 0;
    }

    @Override
    public int getQueryTimeout() {
        return 0;
    }

    @Override
    public void setQueryTimeout(int seconds) {
        // NOT Implemented
    }

    @Override
    public void cancel() {
        // NOT Implemented
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        return resultSet != null ? resultSet.getWarnings() : warnings;
    }

    @Override
    public void clearWarnings() throws SQLException {
        if (resultSet != null) {
            resultSet.clearWarnings();
        }
        warnings = new SQLWarning();
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        log.trace("[PrepStat] execute IMPLEMENTED {}", sql);
        this.updateCount = -1;
        this.updateCountReturned = false;
        this.soqlQuery = sql;
        this.resultSet = executeQuery();
        this.resultSetReturned = false;
        boolean result = this.updateCount < 0;
        log.trace("[PrepStat] execute IMPLEMENTED ({}){}", result, sql);
        return result;
    }

    @Override
    public ResultSet getResultSet() {
        ResultSet toReturn = updateCount < 0 ? resultSet : null;
        if (this.resultSetReturned) {
            log.trace("[PrepStat] getResultSet IMPLEMENTED Already Returned {}\n {}{}",
                soqlQuery,
                (resultSet == null ? " resultSet is NULL" : "resultSet is present"),
                (toReturn == null ? " -> Not to be returned" : " -> Returning"));
            return null;
        }
        this.resultSetReturned = true;
        log.trace("[PrepStat] getResultSet IMPLEMENTED " + soqlQuery + "\n {}{}",
            (resultSet == null ? " resultSet is NULL" : "resultSet is present"),
            (toReturn == null ? " -> Not to be returned" : " -> Returning"));
        return toReturn;
    }

    @Override
    public int getUpdateCount() {
        if (this.updateCountReturned) {
            log.trace("[PrepStat] getUpdateCount Already Returned {}", updateCount + " IMPLEMENTED ");
            return -1;
        }
        log.trace("[PrepStat] getUpdateCount {}", updateCount + " IMPLEMENTED ");
        this.updateCountReturned = true;
        return updateCount;
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        if (updateCount >= 0) {
            log.trace(
                "[PrepStat] getMoreResults IMPLEMENTED (false) updateCount=" + updateCount + " sql=" + soqlQuery);
            return false;
        }
        boolean more = resultSet != null && resultSet.next();
        log.trace(
            "[PrepStat] getMoreResults IMPLEMENTED (" + more + ") updateCount=" + updateCount + " sql=" + soqlQuery);
        return more;
    }

    @Override
    public void setCursorName(String name) {
        // NOT Implemented
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {
        if (direction != ResultSet.FETCH_FORWARD && direction != ResultSet.FETCH_REVERSE
            && direction != ResultSet.FETCH_UNKNOWN) {
            throw new SQLException("Unsupported direction: " + direction);
        } else {
            this.fetchDirection = direction;
        }
    }

    @Override
    public void setMaxFieldSize(int max) {
        // NOT Implemented
    }

    @Override
    public void setEscapeProcessing(boolean enable) {
        // NOT Implemented
    }

    @Override
    public int getFetchDirection() {
        return this.fetchDirection;
    }

    @Override
    public int getResultSetConcurrency() {
        return ResultSet.CONCUR_READ_ONLY;
    }

    @Override
    public int getResultSetType() {
        return ResultSet.TYPE_FORWARD_ONLY;
    }

    @Override
    public void addBatch(String sql) {
        log.trace("[PrepStat] addBatch NOT_IMPLEMENTED {}", sql);
    }

    @Override
    public void clearBatch() {
        log.trace("[PrepStat] clearBatch NOT_IMPLEMENTED");
    }

    @Override
    public int[] executeBatch() {
        log.trace("[PrepStat] executeBatch NOT_IMPLEMENTED");
        return new int[]{};
    }

    @Override
    public Connection getConnection() {
        log.trace("[PrepStat] getConnection IMPLEMENTED ");
        return connection;
    }

    @Override
    public boolean getMoreResults(int current) {
        log.trace("[PrepStat] getMoreResults NOT_IMPLEMENTED");
        return false;
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        if (autoGeneratedKeys != Statement.RETURN_GENERATED_KEYS) {
            throw new SQLException(
                "Cannot return generated keys: query was not set with Statement.RETURN_GENERATED_KEYS");
        }

        return this.resultSet;
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        executeInternal(sql, autoGeneratedKeys);
        return this.updateCount;
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return executeUpdate(sql);
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return executeUpdate(sql);
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        return executeUpdate(sql) > 0;
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return executeUpdate(sql) > 0;
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return executeUpdate(sql) > 0;
    }

    @Override
    public int getResultSetHoldability() {
        return 0;
    }

    @Override
    public boolean isClosed() {
        return false;
    }

    @Override
    public void setPoolable(boolean poolable) {
        log.trace("[PrepStat] setPoolable NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setPoolable is not implemented yet.");
    }

    @Override
    public boolean isPoolable() {
        return false;
    }

    @Override
    public void closeOnCompletion() {
        // NOT Implemented
    }

    @Override
    public boolean isCloseOnCompletion() {
        return false;
    }

    @Override
    public <T> T unwrap(Class<T> iface) {
        log.trace("[PrepStat] unwrap NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The unwrap is not implemented yet.");
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) {
        return false;
    }

    @Override
    public int executeUpdate() throws SQLException {
        return executeUpdate(soqlQuery);
    }

    @Override
    public void clearParameters() {
        log.trace("[PrepStat] clearParameters 2 NOT_IMPLEMENTED");
    }

    @Override
    public boolean execute() throws SQLException {
        return executeUpdate(soqlQuery) > 0;
    }

    @Override
    public void addBatch() {
        log.trace("[PrepStat] addBatch NOT_IMPLEMENTED");
    }

    @Override
    public void setRowId(int parameterIndex, RowId x) {
        log.trace("[PrepStat] setRowId NOT_IMPLEMENTED");
    }

    @Override
    public void setNString(int parameterIndex, String value) {
        log.trace("[PrepStat] setNString IMPLEMENTED ");
        setString(parameterIndex, value);
    }

    @Override
    public void setNCharacterStream(int parameterIndex, Reader value, long length) {
        log.trace("[PrepStat] setNCharacterStream NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setNCharacterStream is not implemented yet.");
    }

    @Override
    public void setNCharacterStream(int parameterIndex, Reader value) {
        log.trace("[PrepStat] setNCharacterStream NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setNCharacterStream is not implemented yet.");
    }

    @Override
    public void setNClob(int parameterIndex, NClob value) {
        log.trace("[PrepStat] setNClob NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setNClob is not implemented yet.");
    }

    @Override
    public void setNClob(int parameterIndex, Reader reader) {
        log.trace("[PrepStat] setNClob NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setNClob is not implemented yet.");
    }

    @Override
    public void setBlob(int parameterIndex, InputStream inputStream, long length) {
        log.trace("[PrepStat] setBlob NOT_IMPLEMENTED");
    }

    @Override
    public void setNClob(int parameterIndex, Reader reader, long length) {
        log.trace("[PrepStat] setNClob NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setNClob is not implemented yet.");
    }

    @Override
    public void setSQLXML(int parameterIndex, SQLXML xmlObject) {
        log.trace("[PrepStat] setSQLXML NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setSQLXML is not implemented yet.");
    }

    @Override
    public void setBinaryStream(int parameterIndex, InputStream x, long length) {
        log.trace("[PrepStat] setBinaryStream NOT_IMPLEMENTED");
    }

    @Override
    public void setBinaryStream(int parameterIndex, InputStream x) {
        log.trace("[PrepStat] setBinaryStream NOT_IMPLEMENTED");
    }

    @Override
    public void setBlob(int parameterIndex, InputStream inputStream) {
        log.trace("[PrepStat] setBlob NOT_IMPLEMENTED");
    }

    @Override
    public void setArray(int i, Array x) {
        log.trace("[PrepStat] setArray NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setArray is not implemented yet.");
    }

    @Override
    public void setAsciiStream(int parameterIndex, InputStream x, int length) {
        log.trace("[PrepStat] setAsciiStream NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setAsciiStream is not implemented yet.");
    }

    @Override
    public void setAsciiStream(int parameterIndex, InputStream x) {
        log.trace("[PrepStat] setAsciiStream NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setAsciiStream is not implemented yet.");
    }

    @Override
    public void setAsciiStream(int parameterIndex, InputStream x, long length) {
        log.trace("[PrepStat] setAsciiStream NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setAsciiStream is not implemented yet.");
    }

    @Override
    public void setBinaryStream(int parameterIndex, InputStream x, int length) {
        log.trace("[PrepStat] setBinaryStream NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setBinaryStream is not implemented yet.");
    }

    @Override
    public void setBlob(int i, Blob x) {
        log.trace("[PrepStat] setBlob NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setBlob is not implemented yet.");
    }

    @Override
    public void setBytes(int parameterIndex, byte[] x) {
        log.trace("[PrepStat] setBytes NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setBytes is not implemented yet.");
    }

    @Override
    public void setCharacterStream(int parameterIndex, Reader reader, int length) {
        log.trace("[PrepStat] setCharacterStream NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setCharacterStream is not implemented yet.");
    }

    @Override
    public void setCharacterStream(int parameterIndex, Reader reader) {
        log.trace("[PrepStat] setCharacterStream NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setCharacterStream is not implemented yet.");
    }

    @Override
    public void setCharacterStream(int parameterIndex, Reader reader, long length) {
        log.trace("[PrepStat] setCharacterStream NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setCharacterStream is not implemented yet.");
    }

    @Override
    public void setClob(int i, Clob x) {
        log.trace("[PrepStat] setClob NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setClob is not implemented yet.");
    }

    @Override
    public void setClob(int parameterIndex, Reader reader, long length) {
        log.trace("[PrepStat] setClob NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setClob is not implemented yet.");
    }

    @Override
    public void setClob(int parameterIndex, Reader reader) {
        log.trace("[PrepStat] setClob NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setClob is not implemented yet.");
    }

    @Override
    public void setDate(int parameterIndex, Date x, Calendar cal) {
        log.trace("[PrepStat] setDate NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setDate is not implemented yet.");
    }

    @Override
    public void setRef(int i, Ref x) {
        log.trace("[PrepStat] setRef NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setRef is not implemented yet.");
    }

    @Override
    public void setTime(int parameterIndex, Time x, Calendar cal) {
        log.trace("[PrepStat] setRef NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setTime is not implemented yet.");
    }

    @Override
    public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) {
        log.trace("[PrepStat] setRef NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setTimestamp is not implemented yet.");
    }

    @Override
    public void setURL(int parameterIndex, URL x) {
        log.trace("[PrepStat] setRef NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setURL is not implemented yet.");
    }

    /**
     * @deprecated Use {@code setCharacterStream}
     */
    @Deprecated(since = "1.2")
    @Override
    public void setUnicodeStream(int parameterIndex, InputStream x, int length) {
        log.trace("[PrepStat] setUnicodeStream NOT_IMPLEMENTED");
        throw new UnsupportedOperationException("The setUnicodeStream is not implemented yet.");
    }
}
