package com.ascendix.jdbc.salesforce.statement;

import com.ascendix.jdbc.salesforce.cache.CacheConfig;
import com.ascendix.jdbc.salesforce.connection.ForceConnection;
import com.ascendix.jdbc.salesforce.delegates.ForceResultField;
import com.ascendix.jdbc.salesforce.delegates.PartnerService;
import com.ascendix.jdbc.salesforce.metadata.ColumnMap;
import com.ascendix.jdbc.salesforce.metadata.ForceDatabaseMetaData;
import com.ascendix.jdbc.salesforce.metadata.TypeInfo;
import com.ascendix.jdbc.salesforce.resultset.CachedResultSet;
import com.ascendix.jdbc.salesforce.statement.processor.AdminQueryProcessor;
import com.ascendix.jdbc.salesforce.statement.processor.DeleteQueryAnalyzer;
import com.ascendix.jdbc.salesforce.statement.processor.DeleteQueryProcessor;
import com.ascendix.jdbc.salesforce.statement.processor.InsertQueryAnalyzer;
import com.ascendix.jdbc.salesforce.statement.processor.InsertQueryProcessor;
import com.ascendix.jdbc.salesforce.statement.processor.QueryAnalyzer;
import com.ascendix.jdbc.salesforce.statement.processor.SoqlQueryAnalyzer;
import com.ascendix.jdbc.salesforce.statement.processor.StatementTypeEnum;
import com.ascendix.jdbc.salesforce.statement.processor.UpdateQueryAnalyzer;
import com.ascendix.jdbc.salesforce.statement.processor.UpdateQueryProcessor;
import com.ascendix.jdbc.salesforce.utils.FieldDefTree;
import com.sforce.ws.ConnectionException;
import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.sql.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import javax.sql.rowset.RowSetMetaDataImpl;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.ehcache.Cache;

@Slf4j
public class ForcePreparedStatement implements PreparedStatement, Iterator<List<ColumnMap<String, Object>>> {

    private static final Pattern CACHE_HINT = Pattern.compile("(?is)\\A\\s*(CACHE\\s*(GLOBAL|SESSION)).*");

    protected enum CacheMode {
        NO_CACHE, GLOBAL, SESSION
    }

    private String soqlQuery;
    private final ForceConnection connection;
    private PartnerService partnerService;
    private ResultSetMetaData metadata;
    private int fetchSize;
    private int maxRows;
    private final List<Object> parameters = new ArrayList<>();
    private CacheMode cacheMode;
    @Setter
    private int updateCount = -1;
    private boolean updateCountReturned = false;
    @Setter
    private ResultSet resultSet;
    private boolean resultSetReturned = false;
    private SQLWarning warnings = new SQLWarning();
    private boolean neverQueriedMore;
    private String queryMoreLocator;
    private int autoGeneratedKeys;
    private int fetchDirection;

    private static final CacheConfig cacheDb = CacheConfig.getInstance();
    private static final Cache<String, CachedResultSet> dataCache = cacheDb.getDataCache();

    public ForcePreparedStatement(ForceConnection connection) {
        if (connection == null) {
            throw new IllegalArgumentException("Invalid value. Connection cannot be null.");
        }
        this.connection = connection;
        this.fetchDirection = ResultSet.FETCH_FORWARD;
        this.autoGeneratedKeys = Statement.NO_GENERATED_KEYS;
        this.partnerService = connection.getPartnerService();
    }

    public ForcePreparedStatement(ForceConnection connection, String soql) {
        this(connection);
        this.soqlQuery = soql;
    }

    public ForcePreparedStatement(ForceConnection connection, String soql, int autoGeneratedKeys) {
        this(connection, soql);
        this.autoGeneratedKeys = autoGeneratedKeys;
    }

    @Override
    public ResultSet executeQuery() throws SQLException {
        executeInternal(soqlQuery, Statement.NO_GENERATED_KEYS);
        return this.resultSet;
    }

    private void executeInternal(String soql, int autoGeneratedKeys) throws SQLException {
        this.metadata = null;
        this.queryAnalyzer = null;
        this.soqlQueryAnalyzer = null;
        this.insertQueryAnalyzer = null;
        this.updateQueryAnalyzer = null;
        this.deleteQueryAnalyzer = null;
        this.resultSet = null;
        this.fieldDefinitions = null;
        this.autoGeneratedKeys = autoGeneratedKeys;
        this.updateCount = -1;
        this.updateCountReturned = false;
        this.resultSetReturned = false;
        setCacheMode(soql);
        this.resultSet = cacheMode == CacheMode.NO_CACHE
                ? query()
                : loadFromDataCache();
    }

    private CachedResultSet query() throws SQLException {
        log.trace("[PrepStat] query IMPLEMENTED {}", soqlQuery);
        if ("SELECT 'keep alive'".equals(soqlQuery)) {
            log.info("[PrepStat] query KEEP ALIVE ");
            return CachedResultSet.EMPTY;
        }

        if (AdminQueryProcessor.isAdminQuery(soqlQuery)) {
            return AdminQueryProcessor.processQuery(this, soqlQuery);
        }

        final QueryAnalyzer analyzer = getQueryAnalyzer();

        if (analyzer.analyse(soqlQuery, StatementTypeEnum.INSERT)) {
            return InsertQueryProcessor.processQuery(this, getParameters(), partnerService, getInsertQueryAnalyzer());
        }
        if (analyzer.analyse(soqlQuery, StatementTypeEnum.UPDATE)) {
            return UpdateQueryProcessor.processQuery(this, getParameters(), partnerService, getUpdateQueryAnalyzer());
        }
        if (analyzer.analyse(soqlQuery, StatementTypeEnum.DELETE)) {
            return DeleteQueryProcessor.processQuery(getParameters(), partnerService, getDeleteQueryAnalyzer());
        }

        try {
            final ResultSetMetaData metaData = getMetaData();
            soqlQuery = prepareQuery(getSoqlQueryAnalyzer().getSoqlQueryString());
            if (cacheMode == CacheMode.NO_CACHE) {
                this.neverQueriedMore = true;
                return new CachedResultSet(this, metaData);
            }
            FieldDefTree fieldDefs = getRootEntityFieldDefinitions();
            List<List<ForceResultField>> forceQueryResult = partnerService.query(soqlQuery, fieldDefs);
            if (!forceQueryResult.isEmpty()) {
                List<ColumnMap<String, Object>> maps = Collections.synchronizedList(new LinkedList<>());
                forceQueryResult.forEach(rec -> maps.add(convertToColumnMap(rec)));
                return new CachedResultSet(maps, metaData);
            } else {
                return new CachedResultSet(Collections.emptyList(), metaData);
            }
        } catch (ConnectionException e) {
            throw new SQLException(e);
        }
    }

    public boolean hasAutoGeneratedKeys() {
        return this.autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS;
    }

    @Override
    public boolean hasNext() {
        return this.neverQueriedMore || this.queryMoreLocator != null;
    }

    @Override
    public List<ColumnMap<String, Object>> next() {
        try {
            Map.Entry<List<List<ForceResultField>>, String> resultEntry;
            if (this.neverQueriedMore) {
                this.neverQueriedMore = false;
                resultEntry = partnerService.queryStart(soqlQuery, getRootEntityFieldDefinitions());
            } else if (this.queryMoreLocator != null) {
                resultEntry = partnerService.queryMore(this.queryMoreLocator, getRootEntityFieldDefinitions());
            } else {
                return Collections.emptyList();
            }
            this.queryMoreLocator = resultEntry.getValue();
            List<ColumnMap<String, Object>> result = Collections.synchronizedList(new LinkedList<>());
            Optional.ofNullable(resultEntry.getKey())
                    .orElseGet(Collections::emptyList)
                    .forEach(rec -> result.add(convertToColumnMap(rec)));
            return result;
        } catch (ConnectionException e) {
            throw new RuntimeException(new SQLException(e));
        }
    }

    private String prepareQuery(String query) {
        log.trace("[PrepStat] prepareQuery IMPLEMENTED {}", query);
        query = preprocessQuery(query);
        return setParams(query);
    }

    private String preprocessQuery(String soqlQuery) {
        // Preprocess some sugar like Date Literals into SOQL format
        // {ts '2021-10-12 00:00:12Z'}
        // 2021-10-12T00:00:12Z
        if (soqlQuery == null) {
            return soqlQuery;
        }
        String soqlQueryProcessed = soqlQuery;
        if (soqlQuery.contains("{ts")) {
            soqlQueryProcessed = soqlQuery.trim()
                    .replaceAll(
                            "\\{ts\\s*'(\\d{4}-\\d{2}-\\d{2})(T|\\s)(\\d{2}:\\d{2}:\\d{2})(Z|[+-]\\d{3,4}|)(\\.\\d+)?'\\s*}",
                            "$1T$3$4Z");
        }
        return soqlQueryProcessed;
    }

    private ColumnMap<String, Object> convertToColumnMap(List<ForceResultField> recordFields) {
        ColumnMap<String, Object> columnMap = new ColumnMap<>();
        // Flatten not only child records, but also Lists of Lists - for Relations - list of subrecords
        recordFields = flatten(recordFields);
        recordFields.stream()
                .map(field -> field == null ? new ForceResultField() : field)
                .forEach(field -> {
                    TypeInfo typeInfo = TypeInfo.OTHER_TYPE_INFO;
                    if (field.getFieldType() != null) {
                        typeInfo = TypeInfo.lookupTypeInfo(field.getFieldType());
                    }
                    if (typeInfo == TypeInfo.OTHER_TYPE_INFO) {
                        typeInfo = findColumnType(field.getName());
                    }
                    String columnLabel = findColumnLabel(field.getName());
                    columnMap.put(field.getFullName(), columnLabel, field.getValue(), typeInfo);
                });
        return columnMap;
    }

    private TypeInfo findColumnType(String name) {
        if (name == null) {
            return TypeInfo.OTHER_TYPE_INFO;
        }
        try {
            for (int i = 1; i <= metadata.getColumnCount(); i++) {
                if (name.equalsIgnoreCase(metadata.getColumnName(i))) {
                    return TypeInfo.lookupTypeInfo(metadata.getColumnTypeName(i));
                }
            }
            String[] prefix = StringUtils.split(name, '.');
            if (prefix.length > 0) {
                name = String.join(".", List.of(prefix).subList(1, prefix.length));
                for (int i = 1; i <= metadata.getColumnCount(); i++) {
                    if (name.equalsIgnoreCase(metadata.getColumnName(i))) {
                        return TypeInfo.lookupTypeInfo(metadata.getColumnTypeName(i));
                    }
                }
            }
        } catch (SQLException e) {
            // ignore
        }
        return TypeInfo.OTHER_TYPE_INFO;
    }

    private String findColumnLabel(String name) {
        if (name == null) {
            return null;
        }
        try {
            for (int i = 1; i <= metadata.getColumnCount(); i++) {
                if (name.equalsIgnoreCase(metadata.getColumnName(i))) {
                    return metadata.getColumnLabel(i);
                }
            }
        } catch (SQLException e) {
            // ignore
        }
        return name;
    }

    protected void setCacheMode(String query) {
        Matcher matcher = CACHE_HINT.matcher(query);
        if (matcher.matches()) {
            String mode = matcher.group(2);
            String hint = matcher.group(1);
            this.soqlQuery = query.replaceFirst(hint, "");
            this.cacheMode = CacheMode.valueOf(mode.toUpperCase());
        } else {
            this.soqlQuery = query;
            this.cacheMode = CacheMode.NO_CACHE;
        }
    }

    private String getCacheKey() {
        String preparedQuery = prepareQuery(soqlQuery);
        String key = cacheMode == CacheMode.GLOBAL
                ? preparedQuery
                : connection.getUUID() + preparedQuery;
        return sha256(key);
    }

    private String sha256(final String key) {
        try {
            final MessageDigest digest = MessageDigest.getInstance("SHA-256");
            final byte[] hash = digest.digest(key.getBytes(StandardCharsets.UTF_8));
            final StringBuilder hexString = new StringBuilder();
            for (final byte b : hash) {
                final String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) {
                    hexString.append('0');
                }
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (Exception ex) {
            return key;
        }
    }

    public List<Object> getParameters() {
        log.trace("[PrepStat] getParameters IMPLEMENTED {}", soqlQuery);
        int paramsCountInQuery = StringUtils.countMatches(soqlQuery, '?');
        log.debug("[PrepStat] getParameters - {}/{} parameters", paramsCountInQuery, parameters.size());
        if (parameters.size() < paramsCountInQuery) {
            parameters.addAll(Collections.nCopies(paramsCountInQuery - parameters.size(), null));
        }
        return parameters;
    }

    protected String setParams(String soql) {
        log.trace("[PrepStat] setParams IMPLEMENTED {}", soql);
        String result = soql;
        for (Object param : getParameters()) {
            String paramRepresentation = convertToSoqlParam(param);
            result = result.replaceFirst("\\?", paramRepresentation);
        }
        return result;
    }

    private static final Map<Class<?>, Function<Object, String>> paramConverters = new HashMap<>();

    public static final String ISO_DATETIME = "yyyy-MM-dd'T'HH:mm:ss'+00:00'";

    static {
        paramConverters.put(String.class, ForcePreparedStatement::toSoqlStringParam);
        paramConverters.put(Object.class, ForcePreparedStatement::toSoqlStringParam);
        paramConverters.put(Boolean.class, Object::toString);
        paramConverters.put(Double.class, Object::toString);
        paramConverters.put(BigDecimal.class, Object::toString);
        paramConverters.put(Float.class, Object::toString);
        paramConverters.put(Integer.class, Object::toString);
        paramConverters.put(Long.class, Object::toString);
        paramConverters.put(Short.class, Object::toString);
        paramConverters.put(java.util.Date.class, new SimpleDateFormat(ISO_DATETIME)::format);
        paramConverters.put(Timestamp.class, new SimpleDateFormat(ISO_DATETIME)::format);
        paramConverters.put(null, p -> "NULL");
    }

    protected static String toSoqlStringParam(Object param) {
        return "'" + param.toString()
            .replaceAll("'", "\\\\'")
            .replaceAll("\\\\", "\\\\\\\\") + "'";
    }

    protected static String convertToSoqlParam(Object paramValue) {
        Class<?> paramClass = getParamClass(paramValue);
        // Convert the string date representation to SOQL
        // like {ts '2021-10-21 12:01:02Z'}
        // to 2021-10-21 12:01:02-0000
        if (paramValue instanceof String param && param.startsWith("{ts")) {
            paramValue = convertStringToDate(param);
        }
        return paramConverters.get(paramClass).apply(paramValue);
    }

    private static java.util.Date convertStringToDate(String paramValue) {
        if (paramValue == null) {
            return null;
        }
        try {
            String paramValueCleared = paramValue.trim()
                    .replaceAll("^\\{ts\\s*'(.*)'}$", "$1")
                    .replaceAll("Z$", "+00:00");
            return new SimpleDateFormat(ISO_DATETIME).parse(paramValueCleared);
        } catch (ParseException e) {
            log.error("Failed to convert value to date [{}]", paramValue, e);
        }
        return null;
    }

    protected static Class<?> getParamClass(Object paramValue) {
        Class<?> paramClass = paramValue != null ? paramValue.getClass() : null;
        if (!paramConverters.containsKey(paramClass)) {
            paramClass = Object.class;
        }
        return paramClass;
    }

    public static ResultSetMetaData createMetaData(ColumnMap<String, Object> row) {
        if (row == null) {
            return null;
        }
        try {
            log.trace("[PrepStat] dummyMetaData IMPLEMENTED");
            RowSetMetaDataImpl result = new RowSetMetaDataImpl();
            int columnsCount = row.size();
            result.setColumnCount(columnsCount);
            for (int i = 1; i <= columnsCount; i++) {
                String fieldName = row.getColumnNames().get(i - 1);
                result.setAutoIncrement(i, false);
                result.setColumnName(i, fieldName);
                result.setColumnLabel(i, fieldName);
                TypeInfo typeInfo = row.getTypes().get(i - 1);
                log.trace(
                        "[PrepStat] createMetaData (" + i + ") " + fieldName + " : " + typeInfo.getTypeName() + " => "
                                + typeInfo.getSqlDataType());
                result.setColumnType(i, typeInfo.getSqlDataType());
                result.setColumnTypeName(i, typeInfo.getTypeName());
                result.setPrecision(i, typeInfo.getPrecision());
                result.setSchemaName(i, ForceDatabaseMetaData.DEFAULT_SCHEMA);
                result.setCatalogName(i, ForceDatabaseMetaData.DEFAULT_CATALOG);
                result.setTableName(i, null);
                result.setCaseSensitive(i, false);
            }
            return result;
        } catch (Exception e) {
            // Ignore for metadata - just return empty
            log.warn("Failed to compile dummy metadata information", e);
            return null;
        }
    }

    private ResultSetMetaData loadMetaData() throws SQLException {
        try {
            log.trace("[PrepStat] loadMetaData IMPLEMENTED");
            if (metadata == null) {
                RowSetMetaDataImpl result = new RowSetMetaDataImpl();
                SoqlQueryAnalyzer analyzer = getSoqlQueryAnalyzer();
                FieldDefTree rootFieldDefinitions = getRootEntityFieldDefinitions();
                List<FieldDef> resultFieldDefinitions = rootFieldDefinitions.flatten();
                int columnsCount = resultFieldDefinitions.size();
                result.setColumnCount(columnsCount);
                for (int i = 1; i <= columnsCount; i++) {
                    FieldDef field = resultFieldDefinitions.get(i - 1);
                    result.setAutoIncrement(i, false);
                    result.setColumnName(i, field.getFullName());
                    result.setColumnLabel(i, field.getAlias());
                    String forceTypeName = field.getType();
                    TypeInfo typeInfo = TypeInfo.lookupTypeInfo(forceTypeName);
                    result.setColumnType(i, typeInfo.getSqlDataType());
                    result.setColumnTypeName(i, typeInfo.getTypeName());
                    result.setPrecision(i, typeInfo.getPrecision());
                    result.setSchemaName(i, ForceDatabaseMetaData.DEFAULT_SCHEMA);
                    result.setCatalogName(i, ForceDatabaseMetaData.DEFAULT_CATALOG);
                    result.setTableName(i, analyzer.getFromObjectName());
                    result.setCaseSensitive(i, false);
                }
                metadata = result;
            }
            return metadata;
        } catch (RuntimeException e) {
            throw new SQLException(e.getCause() != null ? e.getCause() : e);
        }
    }

    private <T> List<T> flatten(List<T> listWithLists) {
        return listWithLists.stream()
                .flatMap(
                        def -> def instanceof Collection
                                ? flatten((List<T>) def).stream() // MultiLevel flattening
                                : Stream.of(def)
                ).toList();
    }

    private FieldDefTree fieldDefinitions;

    private FieldDefTree getRootEntityFieldDefinitions() {
        log.trace("[PrepStat] getFieldDefinitions IMPLEMENTED ");
        if (fieldDefinitions == null) {
            fieldDefinitions = getSoqlQueryAnalyzer().getFieldDefinitions();
            log.info("[PrepStat] getFieldDefinitions:\n {}", fieldDefinitions.toTree());
        }
        return fieldDefinitions;
    }

    private QueryAnalyzer queryAnalyzer;
    private SoqlQueryAnalyzer soqlQueryAnalyzer;
    private InsertQueryAnalyzer insertQueryAnalyzer;
    private UpdateQueryAnalyzer updateQueryAnalyzer;
    private DeleteQueryAnalyzer deleteQueryAnalyzer;

    private QueryAnalyzer getQueryAnalyzer() {
        if (queryAnalyzer == null) {
            queryAnalyzer = new QueryAnalyzer(soqlQuery, this::runResolveSubselect, partnerService);
        }
        return queryAnalyzer;
    }

    private SoqlQueryAnalyzer getSoqlQueryAnalyzer() {
        if (soqlQueryAnalyzer == null) {
            soqlQueryAnalyzer = new SoqlQueryAnalyzer(getQueryAnalyzer());
            if (soqlQueryAnalyzer.isExpandedStarSyntaxForFields()) {
                this.soqlQuery = soqlQueryAnalyzer.getSoqlQueryString();
                log.info("[PrepStat] Expanded Star Syntax to {}", soqlQuery);
            }
        }
        return soqlQueryAnalyzer;
    }

    private InsertQueryAnalyzer getInsertQueryAnalyzer() {
        if (insertQueryAnalyzer == null) {
            insertQueryAnalyzer = new InsertQueryAnalyzer(getQueryAnalyzer());
        }
        return insertQueryAnalyzer;
    }

    private UpdateQueryAnalyzer getUpdateQueryAnalyzer() {
        if (updateQueryAnalyzer == null) {
            updateQueryAnalyzer = new UpdateQueryAnalyzer(getQueryAnalyzer());
        }
        return updateQueryAnalyzer;
    }

    private DeleteQueryAnalyzer getDeleteQueryAnalyzer() {
        if (deleteQueryAnalyzer == null) {
            deleteQueryAnalyzer = new DeleteQueryAnalyzer(getQueryAnalyzer());
        }
        return deleteQueryAnalyzer;
    }

    private List<Map<String, Object>> runResolveSubselect(String soql, List<Object> parameters) {
        List<Map<String, Object>> results = new ArrayList<>();
        log.info("Resolving subselect \n{}", soql);
        try {
            ForcePreparedStatement forcePreparedStatement = new ForcePreparedStatement(connection, soql);
            forcePreparedStatement.addParameters(parameters);
            ResultSet rs = forcePreparedStatement.query();

            while (rs.next()) {
                // LinkedHashMap is needed to save the order of the fields
                Map<String, Object> rec = new LinkedHashMap<>();
                results.add(rec);
                for (int i = 0; i < rs.getMetaData().getColumnCount(); i++) {
                    rec.put(rs.getMetaData().getColumnName(i + 1), rs.getString(i + 1));
                }
            }
            log.info("  {} records resolved with {} columns", results.size(), rs.getMetaData().getColumnCount());
        } catch (Exception e) {
            log.warn("Failed to resolve sub-select \n{}", soql, e);
            this.warnings.addSuppressed(new SQLWarning("Failed to resolve sub-select \n" + soql, e));
            throw new IllegalArgumentException("Failed to resolve sub-select: " + e.getMessage());
        }

        return results;
    }

    @Override
    public ParameterMetaData getParameterMetaData() {
        return new ParameterMetadataImpl(parameters, soqlQuery);
    }

    public ResultSetMetaData getMetaData() throws SQLException {
        log.trace("[PrepStat] getMetaData IMPLEMENTED ");
        return cacheMode == CacheMode.NO_CACHE
                ? loadMetaData()
                : loadFromMetaDataCache();
    }

    private ResultSetMetaData loadFromMetaDataCache() throws SQLException {
        String key = getCacheKey();
        if (dataCache.containsKey(key)) {
            CachedResultSet value = dataCache.get(key);
            value.beforeFirst();
            return value.getMetaData();
        }

        ResultSetMetaData value;
        value = loadMetaData();

        this.metadata = value;
        return value;
    }

    private synchronized ResultSet loadFromDataCache() throws SQLException {
        CachedResultSet value;
        String key = getCacheKey();
        if (dataCache.containsKey(key)) {
            value = dataCache.get(key);
            value.beforeFirst();
            return value;
        }

        value = query();
        dataCache.put(key, value);
        return value;
    }

    public boolean reconnect(String url, String userName, String userPass) throws ConnectionException {
        log.trace("[PrepStat] RECONNECT IMPLEMENTED newUserName={} url={}", userName, url);
        boolean updated = connection.updatePartnerConnection(url, userName, userPass);
        this.partnerService = connection.getPartnerService();
        return updated;
    }

    @Override
    public void setFetchSize(int rows) {
        this.fetchSize = rows;
    }

    @Override
    public int getFetchSize() {
        return fetchSize;
    }

    @Override
    public void setMaxRows(int max) {
        this.maxRows = max;
    }

    @Override
    public int getMaxRows() {
        return maxRows;
    }

    private void addParameters(List<Object> parameters) {
        this.parameters.addAll(parameters);
    }

    protected void addParameter(int parameterIndex, Object x) {
        log.trace("[PrepStat] addParameter {} IMPLEMENTED", parameterIndex);
        parameterIndex--;
        if (parameters.size() < parameterIndex) {
            parameters.addAll(Collections.nCopies(parameterIndex - parameters.size(), null));
        }
        parameters.add(parameterIndex, x);
    }

    @Override
    public void setBigDecimal(int parameterIndex, BigDecimal x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setBoolean(int parameterIndex, boolean x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setByte(int parameterIndex, byte x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setDate(int parameterIndex, Date x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setDouble(int parameterIndex, double x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setFloat(int parameterIndex, float x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setInt(int parameterIndex, int x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setLong(int parameterIndex, long x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setNull(int parameterIndex, int sqlType) {
        addParameter(parameterIndex, null);
    }

    @Override
    public void setNull(int paramIndex, int sqlType, String typeName) {
        addParameter(paramIndex, null);
    }

    @Override
    public void setObject(int parameterIndex, Object x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setObject(int parameterIndex, Object x, int targetSqlType) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setShort(int parameterIndex, short x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setString(int parameterIndex, String x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setTime(int parameterIndex, Time x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public void setTimestamp(int parameterIndex, Timestamp x) {
        addParameter(parameterIndex, x);
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        log.trace("[PrepStat] executeQuery IMPLEMENTED {}", sql);
        this.soqlQuery = sql;
        this.resultSet = executeQuery();
        return this.resultSet;
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        return executeUpdate(sql, this.autoGeneratedKeys);
    }

    // Not required to implement below

    @Override
    public void close() {
        parameters.clear();
    }

    @Override
    public int getMaxFieldSize() {
        return 0;
    }

    @Override
    public int getQueryTimeout() {
        return 0;
    }

    @Override
    public void setQueryTimeout(int seconds) {
        // NOT Implemented
    }

    @Override
    public void cancel() {
        // NOT Implemented
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        return resultSet != null ? resultSet.getWarnings() : warnings;
    }

    @Override
    public void clearWarnings() throws SQLException {
        if (resultSet != null) {
            resultSet.clearWarnings();
        }
        warnings = new SQLWarning();
    }

    @Override
    public boolean execute(String sql) throws SQLException {
        log.trace("[PrepStat] execute IMPLEMENTED {}", sql);
        this.updateCount = -1;
        this.updateCountReturned = false;
        this.soqlQuery = sql;
        this.resultSet = executeQuery();
        this.resultSetReturned = false;
        boolean result = this.updateCount < 0;
        log.trace("[PrepStat] execute IMPLEMENTED ({}){}", result, sql);
        return result;
    }

    @Override
    public ResultSet getResultSet() {
        ResultSet toReturn = updateCount < 0 ? resultSet : null;
        if (this.resultSetReturned) {
            log.trace("[PrepStat] getResultSet IMPLEMENTED Already Returned {}\n {}{}",
                    soqlQuery,
                    (resultSet == null ? " resultSet is NULL" : "resultSet is present"),
                    (toReturn == null ? " -> Not to be returned" : " -> Returning"));
            return null;
        }
        this.resultSetReturned = true;
        log.trace("[PrepStat] getResultSet IMPLEMENTED " + soqlQuery + "\n {}{}",
                (resultSet == null ? " resultSet is NULL" : "resultSet is present"),
                (toReturn == null ? " -> Not to be returned" : " -> Returning"));
        return toReturn;
    }

    @Override
    public int getUpdateCount() {
        if (this.updateCountReturned) {
            log.trace("[PrepStat] getUpdateCount Already Returned {}", updateCount + " IMPLEMENTED ");
            return -1;
        }
        log.trace("[PrepStat] getUpdateCount {}", updateCount + " IMPLEMENTED ");
        this.updateCountReturned = true;
        return updateCount;
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        if (updateCount >= 0) {
            log.trace(
                    "[PrepStat] getMoreResults IMPLEMENTED (false) updateCount=" + updateCount + " sql=" + soqlQuery);
            return false;
        }
        boolean more = resultSet != null && resultSet.next();
        log.trace(
                "[PrepStat] getMoreResults IMPLEMENTED (" + more + ") updateCount=" + updateCount + " sql=" + soqlQuery);
        return more;
    }

    @Override
    public void setCursorName(String name) {
        // NOT Implemented
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {
        if (direction != ResultSet.FETCH_FORWARD && direction != ResultSet.FETCH_REVERSE
                && direction != ResultSet.FETCH_UNKNOWN) {
            throw new SQLException("Unsupported direction: " + direction);
        } else {
            this.fetchDirection = direction;
        }
    }

    @Override
    public void setMaxFieldSize(int max) {
        // NOT Implemented
    }

    @Override
    public void setEscapeProcessing(boolean enable) {
        // NOT Implemented
    }

    @Override
    public int getFetchDirection() {
        return this.fetchDirection;
    }

    @Override
    public int getResultSetConcurrency() {
        return ResultSet.CONCUR_READ_ONLY;
    }

    @Override
    public int getResultSetType() {
        return ResultSet.TYPE_FORWARD_ONLY;
    }

    @Override
    public Connection getConnection() {
        return connection;
    }

    @Override
    public boolean getMoreResults(int current) {
        log.trace("[PrepStat] getMoreResults NOT_IMPLEMENTED");
        return false;
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        if (autoGeneratedKeys != Statement.RETURN_GENERATED_KEYS) {
            throw new SQLException(
                    "Cannot return generated keys: query was not set with Statement.RETURN_GENERATED_KEYS");
        }

        return this.resultSet;
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        executeInternal(sql, autoGeneratedKeys);
        return this.updateCount;
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return executeUpdate(sql);
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return executeUpdate(sql);
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        return executeUpdate(sql) > 0;
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return executeUpdate(sql) > 0;
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return executeUpdate(sql) > 0;
    }

    @Override
    public int getResultSetHoldability() {
        return 0;
    }

    @Override
    public boolean isClosed() {
        return false;
    }

    @Override
    public boolean isPoolable() {
        return false;
    }

    @Override
    public void closeOnCompletion() {
        // NOT Implemented
    }

    @Override
    public boolean isCloseOnCompletion() {
        return false;
    }

    @Override
    public <T> T unwrap(Class<T> iface) {
        return iface.isInstance(this) ? iface.cast(this) : null;
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) {
        return iface.isInstance(this);
    }

    @Override
    public int executeUpdate() throws SQLException {
        return executeUpdate(soqlQuery);
    }

    @Override
    public void clearParameters() {
        parameters.clear();
    }

    @Override
    public boolean execute() throws SQLException {
        executeInternal(soqlQuery, autoGeneratedKeys);
        return true;
    }

    @Override
    public void setNString(int parameterIndex, String value) {
        setString(parameterIndex, value);
    }

    @Override
    public void addBatch() throws SQLException {
        throw new SQLFeatureNotSupportedException("The addBatch is not implemented yet.");
    }

    @Override
    public void addBatch(String sql) throws SQLException {
        throw new SQLFeatureNotSupportedException("The addBatch is not implemented yet.");
    }

    @Override
    public void clearBatch() throws SQLException {
        throw new SQLFeatureNotSupportedException("The clearBatch is not implemented yet.");
    }

    @Override
    public int[] executeBatch() throws SQLException {
        throw new SQLFeatureNotSupportedException("The executeBatch is not implemented yet.");
    }

    @Override
    public void setPoolable(boolean poolable) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setPoolable is not implemented yet.");
    }

    @Override
    public void setRowId(int parameterIndex, RowId x) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setRowId is not implemented yet.");
    }

    @Override
    public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setNCharacterStream is not implemented yet.");
    }

    @Override
    public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setNCharacterStream is not implemented yet.");
    }

    @Override
    public void setNClob(int parameterIndex, NClob value) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setNClob is not implemented yet.");
    }

    @Override
    public void setNClob(int parameterIndex, Reader reader) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setNClob is not implemented yet.");
    }

    @Override
    public void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setBlob is not implemented yet.");
    }

    @Override
    public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setNClob is not implemented yet.");
    }

    @Override
    public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setSQLXML is not implemented yet.");
    }

    @Override
    public void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setBinaryStream is not implemented yet.");
    }

    @Override
    public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setBinaryStream is not implemented yet.");
    }

    @Override
    public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setBlob is not implemented yet.");
    }

    @Override
    public void setArray(int i, Array x) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setArray is not implemented yet.");
    }

    @Override
    public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setAsciiStream is not implemented yet.");
    }

    @Override
    public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setAsciiStream is not implemented yet.");
    }

    @Override
    public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setAsciiStream is not implemented yet.");
    }

    @Override
    public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setBinaryStream is not implemented yet.");
    }

    @Override
    public void setBlob(int i, Blob x) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setBlob is not implemented yet.");
    }

    @Override
    public void setBytes(int parameterIndex, byte[] x) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setBytes is not implemented yet.");
    }

    @Override
    public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setCharacterStream is not implemented yet.");
    }

    @Override
    public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setCharacterStream is not implemented yet.");
    }

    @Override
    public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setCharacterStream is not implemented yet.");
    }

    @Override
    public void setClob(int i, Clob x) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setClob is not implemented yet.");
    }

    @Override
    public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setClob is not implemented yet.");
    }

    @Override
    public void setClob(int parameterIndex, Reader reader) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setClob is not implemented yet.");
    }

    @Override
    public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setDate is not implemented yet.");
    }

    @Override
    public void setRef(int i, Ref x) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setRef is not implemented yet.");
    }

    @Override
    public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setTime is not implemented yet.");
    }

    @Override
    public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setTimestamp is not implemented yet.");
    }

    @Override
    public void setURL(int parameterIndex, URL x) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setURL is not implemented yet.");
    }

    /**
     * @deprecated Use {@code setCharacterStream}
     */
    @Deprecated(since = "1.2")
    @Override
    public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException {
        throw new SQLFeatureNotSupportedException("The setUnicodeStream is not implemented yet.");
    }
}
